
'use server';

import { suggestRecipes, type SuggestRecipesInput, type SuggestRecipesOutput } from '@/ai/flows/suggest-recipes';
import { saveInsight } from '@/lib/data';
import type { Insight, User } from '@/types';
import { getKitchenCoachAdvice, type KitchenCoachInput, type KitchenCoachOutput } from '@/ai/flows/get-kitchen-coach-advice';
import { getCoachSolutions, type GetCoachSolutionsInput, type GetCoachSolutionsOutput } from '@/ai/flows/get-coach-solutions';
import { analyzeWastePatterns as analyzeWastePatternsFlow, type AnalyzeWastePatternsInput, type AnalyzeWastePatternsOutput } from '@/ai/flows/analyze-waste-patterns';
import { getWasteBreakdownInsight as getWasteBreakdownInsightFlow, type GetWasteBreakdownInsightInput, type GetWasteBreakdownInsightOutput } from '@/ai/flows/get-waste-breakdown-insight';
import { getItemInsights, type GetItemInsightsInput, type GetItemInsightsOutput } from '@/ai/flows/get-item-insights';

/**
 * Server Action to get recipe suggestions.
 * This acts as a secure bridge between the client and the AI flow.
 * @param input - The ingredients and preferences from the user.
 * @returns A promise that resolves to the recipe suggestions including images.
 */
export async function getRecipeSuggestions(input: SuggestRecipesInput): Promise<SuggestRecipesOutput> {
    try {
        const result = await suggestRecipes(input);
        if (!result || !result.recipes) {
            console.log("No recipes were generated by the flow.");
            return { recipes: [] };
        }
        return result;
    } catch (error) {
        console.error("Error getting recipe recommendation in server action:", error);
        // In a real app, you might want more sophisticated error handling here.
        // For now, we'll re-throw to let the client-side catch it.
        throw new Error("Failed to generate recipe recommendations.");
    }
}

export async function getCoachAdvice(input: KitchenCoachInput): Promise<KitchenCoachOutput> {
    try {
        return await getKitchenCoachAdvice(input);
    } catch (error) {
        console.error("Error getting kitchen coach advice in server action:", error);
        throw new Error("Failed to get advice from the Kitchen Coach.");
    }
}

export async function fetchCoachSolutions(input: GetCoachSolutionsInput): Promise<GetCoachSolutionsOutput> {
    try {
        return await getCoachSolutions(input);
    } catch (error) {
        console.error("Error getting kitchen coach solutions in server action:", error);
        throw new Error("Failed to get solutions from the Kitchen Coach.");
    }
}

export async function analyzeWastePatterns(input: AnalyzeWastePatternsInput): Promise<AnalyzeWastePatternsOutput> {
    try {
        return await analyzeWastePatternsFlow(input);
    } catch (error) {
        console.error("Error analyzing waste patterns in server action:", error);
        throw new Error("Failed to analyze waste patterns.");
    }
}

export async function getWasteBreakdownInsight(input: GetWasteBreakdownInsightInput): Promise<GetWasteBreakdownInsightOutput> {
    try {
        return await getWasteBreakdownInsightFlow(input);
    } catch (error) {
        console.error("Error getting waste breakdown insight in server action:", error);
        throw new Error("Failed to get waste breakdown insight.");
    }
}


export async function fetchItemInsights(input: GetItemInsightsInput): Promise<GetItemInsightsOutput> {
    try {
        return await getItemInsights(input);
    } catch (error) {
        console.error("Error getting item insights in server action:", error);
        throw new Error("Failed to get item insights.");
    }
}
